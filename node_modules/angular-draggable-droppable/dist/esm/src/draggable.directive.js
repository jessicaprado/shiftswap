import { Directive, ElementRef, Renderer, Output, EventEmitter, Input, NgZone } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/merge';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/take';
import 'rxjs/add/operator/takeLast';
import 'rxjs/add/operator/pairwise';
import 'rxjs/add/operator/share';
import { DraggableHelper } from './draggableHelper.provider';
var MOVE_CURSOR = 'move';
export var Draggable = (function () {
    /**
     * @hidden
     */
    function Draggable(element, renderer, draggableHelper, zone) {
        this.element = element;
        this.renderer = renderer;
        this.draggableHelper = draggableHelper;
        this.zone = zone;
        this.dragAxis = { x: true, y: true };
        this.dragSnapGrid = {};
        this.ghostDragEnabled = true;
        this.dragStart = new EventEmitter();
        this.dragging = new EventEmitter();
        this.dragEnd = new EventEmitter();
        /**
         * @hidden
         */
        this.mouseDown = new Subject();
        /**
         * @hidden
         */
        this.mouseMove = new Subject();
        /**
         * @hidden
         */
        this.mouseUp = new Subject();
        this.eventListenerSubscriptions = {};
    }
    Draggable.prototype.ngOnInit = function () {
        var _this = this;
        this.checkEventListeners();
        var mouseDrag = this.mouseDown
            .filter(function () { return _this.canDrag(); })
            .flatMap(function (mouseDownEvent) {
            _this.zone.run(function () {
                _this.dragStart.next({ x: 0, y: 0 });
            });
            _this.setCursor(MOVE_CURSOR);
            var currentDrag = new Subject();
            _this.draggableHelper.currentDrag.next(currentDrag);
            var mouseMove = _this.mouseMove
                .map(function (mouseMoveEvent) {
                mouseMoveEvent.preventDefault();
                return {
                    currentDrag: currentDrag,
                    x: mouseMoveEvent.clientX - mouseDownEvent.clientX,
                    y: mouseMoveEvent.clientY - mouseDownEvent.clientY,
                    clientX: mouseMoveEvent.clientX,
                    clientY: mouseMoveEvent.clientY
                };
            })
                .map(function (moveData) {
                if (_this.dragSnapGrid.x) {
                    moveData.x = Math.floor(moveData.x / _this.dragSnapGrid.x) * _this.dragSnapGrid.x;
                }
                if (_this.dragSnapGrid.y) {
                    moveData.y = Math.floor(moveData.y / _this.dragSnapGrid.y) * _this.dragSnapGrid.y;
                }
                return moveData;
            })
                .map(function (moveData) {
                if (!_this.dragAxis.x) {
                    moveData.x = 0;
                }
                if (!_this.dragAxis.y) {
                    moveData.y = 0;
                }
                return moveData;
            })
                .filter(function (_a) {
                var x = _a.x, y = _a.y;
                return !_this.validateDrag || _this.validateDrag({ x: x, y: y });
            })
                .takeUntil(Observable.merge(_this.mouseUp, _this.mouseDown));
            mouseMove.takeLast(1).subscribe(function (_a) {
                var x = _a.x, y = _a.y;
                _this.zone.run(function () {
                    _this.dragEnd.next({ x: x, y: y });
                });
                currentDrag.complete();
                _this.setCssTransform(null);
                if (_this.ghostDragEnabled) {
                    _this.renderer.setElementStyle(_this.element.nativeElement, 'pointerEvents', null);
                }
            });
            return mouseMove;
        })
            .share();
        Observable
            .merge(mouseDrag.take(1).map(function (value) { return [, value]; }), mouseDrag.pairwise())
            .filter(function (_a) {
            var previous = _a[0], next = _a[1];
            if (!previous) {
                return true;
            }
            return previous.x !== next.x || previous.y !== next.y;
        })
            .map(function (_a) {
            var previous = _a[0], next = _a[1];
            return next;
        })
            .subscribe(function (_a) {
            var x = _a.x, y = _a.y, currentDrag = _a.currentDrag, clientX = _a.clientX, clientY = _a.clientY;
            _this.zone.run(function () {
                _this.dragging.next({ x: x, y: y });
            });
            if (_this.ghostDragEnabled) {
                _this.renderer.setElementStyle(_this.element.nativeElement, 'pointerEvents', 'none');
            }
            _this.setCssTransform("translate(" + x + "px, " + y + "px)");
            currentDrag.next({
                clientX: clientX,
                clientY: clientY,
                dropData: _this.dropData
            });
        });
    };
    Draggable.prototype.ngOnChanges = function (changes) {
        if (changes['dragAxis']) {
            this.checkEventListeners();
        }
    };
    Draggable.prototype.ngOnDestroy = function () {
        this.unsubscribeEventListeners();
        this.mouseDown.complete();
        this.mouseMove.complete();
        this.mouseUp.complete();
    };
    Draggable.prototype.checkEventListeners = function () {
        var _this = this;
        var canDrag = this.canDrag();
        var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;
        if (canDrag && !hasEventListeners) {
            this.zone.runOutsideAngular(function () {
                _this.eventListenerSubscriptions.mousedown = _this.renderer.listen(_this.element.nativeElement, 'mousedown', function (event) {
                    _this.onMouseDown(event);
                });
                _this.eventListenerSubscriptions.mouseup = _this.renderer.listenGlobal('document', 'mouseup', function (event) {
                    _this.onMouseUp(event);
                });
                _this.eventListenerSubscriptions.mouseenter = _this.renderer.listen(_this.element.nativeElement, 'mouseenter', function () {
                    _this.onMouseEnter();
                });
                _this.eventListenerSubscriptions.mouseleave = _this.renderer.listen(_this.element.nativeElement, 'mouseleave', function () {
                    _this.onMouseLeave();
                });
            });
        }
        else if (!canDrag && hasEventListeners) {
            this.unsubscribeEventListeners();
        }
    };
    Draggable.prototype.onMouseDown = function (event) {
        var _this = this;
        if (!this.eventListenerSubscriptions.mousemove) {
            this.eventListenerSubscriptions.mousemove = this.renderer.listenGlobal('document', 'mousemove', function (event) {
                _this.mouseMove.next(event);
            });
        }
        this.mouseDown.next(event);
    };
    Draggable.prototype.onMouseUp = function (event) {
        if (this.eventListenerSubscriptions.mousemove) {
            this.eventListenerSubscriptions.mousemove();
            delete this.eventListenerSubscriptions.mousemove;
        }
        this.mouseUp.next(event);
    };
    Draggable.prototype.onMouseEnter = function () {
        this.setCursor(MOVE_CURSOR);
    };
    Draggable.prototype.onMouseLeave = function () {
        this.setCursor(null);
    };
    Draggable.prototype.setCssTransform = function (value) {
        if (this.ghostDragEnabled) {
            this.renderer.setElementStyle(this.element.nativeElement, 'transform', value);
            this.renderer.setElementStyle(this.element.nativeElement, '-webkit-transform', value);
            this.renderer.setElementStyle(this.element.nativeElement, '-ms-transform', value);
            this.renderer.setElementStyle(this.element.nativeElement, '-moz-transform', value);
            this.renderer.setElementStyle(this.element.nativeElement, '-o-transform', value);
        }
    };
    Draggable.prototype.canDrag = function () {
        return this.dragAxis.x || this.dragAxis.y;
    };
    Draggable.prototype.setCursor = function (value) {
        this.renderer.setElementStyle(this.element.nativeElement, 'cursor', value);
    };
    Draggable.prototype.unsubscribeEventListeners = function () {
        var _this = this;
        Object.keys(this.eventListenerSubscriptions).forEach(function (type) {
            _this.eventListenerSubscriptions[type]();
            delete _this.eventListenerSubscriptions[type];
        });
    };
    Draggable.decorators = [
        { type: Directive, args: [{
                    selector: '[mwlDraggable]'
                },] },
    ];
    /** @nocollapse */
    Draggable.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer, },
        { type: DraggableHelper, },
        { type: NgZone, },
    ]; };
    Draggable.propDecorators = {
        'dropData': [{ type: Input },],
        'dragAxis': [{ type: Input },],
        'dragSnapGrid': [{ type: Input },],
        'ghostDragEnabled': [{ type: Input },],
        'validateDrag': [{ type: Input },],
        'dragStart': [{ type: Output },],
        'dragging': [{ type: Output },],
        'dragEnd': [{ type: Output },],
    };
    return Draggable;
}());
//# sourceMappingURL=draggable.directive.js.map